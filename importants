files in database = collection
data in file = records/document

show dbs
use database_name
db.dropDatabase()

db.createCollection("collection_name")
db.old_name.renameCollection("New_name")
db.collection_name.drop()
show collections
db.help()
db.collection_name.help()

-------------------------------------------📁 Database Commands
Command	Description
show dbs	Lists all available databases
use database_name	Switches to (or creates) a database
db	Displays the current database
db.dropDatabase()	Deletes the current database
show collections	Lists all collections in the current database
db.stats()	Shows statistics for the current database

-------------------------------------------📦 Collection Commands
Command	Description
db.createCollection("collection_name")	Creates a new collection
db.collection_name.drop()	Deletes a collection
db.old_name.renameCollection("new_name")	Renames a collection (you must be in the admin database or use full namespace syntax like db.getSiblingDB('mydb').mycol.renameCollection(...))
show collections	Lists all collections in the current database





## 📦 **Database Formats: SQL vs NoSQL vs JSON/BSON**

Databases can be stored in **tabular (SQL)** or **JSON/BSON (NoSQL)** formats for easier access and flexibility.

---

### 🗂️ **SQL (Structured Query Language)**

* **Type**: Relational Database
* **Structure**: Tables (rows and columns)
* **Examples**: MySQL, PostgreSQL, Oracle
* **Used For**: Transactional databases
* **Schema**: Fixed

#### 🔧 Schema Definition:

* Blueprint of the database
* Defines:

  * Tables
  * Columns
  * Data types
  * Relationships (e.g., foreign keys)

---

### 📁 **NoSQL (Not Only SQL)**

* **Type**: Non-relational Database
* **Structure**: Collections
* **Examples**: MongoDB, Firebase, CouchDB
* **Used For**: Non-transactional or real-time applications
* **Data Format**: JSON
* **Schema**: Flexible or schema-less

---

## 🧾 **JSON vs BSON**

### 📄 **JSON (JavaScript Object Notation)**

* **Format**: Text-based, human-readable

* **Used For**: Data exchange between client and server, file storage

* **Data Types**:

  * String
  * Number
  * Boolean
  * null
  * Array
  * Object

* **Performance**:

  * Larger file size due to text overhead
  * Slower parsing and generation

---

### 📦 **BSON (Binary JSON)**

* **Format**: Binary-based, not human-readable
* **Used By**: MongoDB (for database storage)

* **Advantages**:

  * Faster to parse and generate
  * More compact and efficient than JSON
  * Supports more data types

#### 🧬 Data Types in BSON:

* String
* Double
* 32-bit Integer
* 64-bit Integer
* Boolean
* null
* Array
* Object
* Timestamp
* Date
* Regular Expression
* ObjectId

---

## 🌍 **Advantages of NoSQL & BSON**

In MongoDB, a schema refers to the structure or blueprint of how data is organized 
in a collection — like what fields exist
in a document, their data types, relationships, constraints, etc.


* Flexible schema design
* Horizontal scalability through **sharding**

* *Sharding*: Adding multiple servers when one server's storage is full
* High performance for read/write operations
* Powerful query language
* Built-in replication for high availability
* Geospatial data support (e.g., coordinates, maps)
* Stores data in a JSON-like BSON format
* Real time analytics capability
* easy integration with big data tools
* Open source and community driven

---

### 🟩 **MongoDB**

* **Type**: NoSQL database
* **Format**: BSON (Binary JSON)
* **Strengths**:

  * Schema flexibility
  * Scalability (horizontal scaling with sharding)
  * High availability (via replication)
  * Supports rich data types and queries
  * Great for handling large volumes of unstructured or semi-structured data

---




















//  PEXELS
// DEVUI

// react-routing => browserRoter
// ---------------------------------------------------friebase
// npm install firebase
// copy the config
// import { getAuth } from "firebase/auth";
// import {getDataBase} from "firebase/database";

// const app = initializeApp(firebaseConfig);
// const auth = getAuth(app);
// const database = getDataBase(app);

// export { auth, database };
// ----------------------------------------------------------------------------FOR TAILWIND
// npm install -D tailwindcss postcss autoprefixer

// npx tailwindcss init -p

// /** @type {import('tailwindcss').Config} */
// module.exports = {
//   content: [
//     "./index.html",
//     "./src/**/*.{js,ts,jsx,tsx}",
//   ],
//   theme: {
//     extend: {},
//   },
//   plugins: [],
// }

// @import "tailwindcss";


// ------------------------------------REACT ROUTER INSTALLATION----------------------------------
// npm i react-router-dom
// ----------------------------------------------------------
{/* <link> === a 
when we use  a tag it will
refresh the whole page */}

{/* <NavLink></NavLink> */}
// we write to in this


// ------------------------------------redux_Toolkit----------------------------------
// npm install @reduxjs/toolkit react-redux
// npm install react-redux
// in store you have to make a folder calle createSlice(logic of the app) and then you have to make 
// a folder called reducer(logic of the app)




// ------------------------------------redux
// npm i react-redux redux
// /we use redux because we want to share the state between the components 
// without facing prop drilling problem 
//actions , reducers , storecreate

// make a store.js file

// // import { configureStore } from '@reduxjs/toolkit';

// import {configureStore, configureSTore} from '@reduxjs/toolkit'
// import todoReducer from '../features/todo/todoSlice'
// export const store = configureStore({
//     reducer:todoReducer
// })

// ---useState
// 1)when state changed
// 2)when prop change


// -------reducers
// we pass function in the reducers

// npm = node package manager
// npx = node package executor
// npm run dev and npm run start diff



